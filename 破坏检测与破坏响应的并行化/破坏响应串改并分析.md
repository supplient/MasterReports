# 粗略的流程
* 由被切割粒子确定被切割簇
* 对每个被切割簇
  * 搜索被切割簇的极大连通子图（待合并新簇）
* 对每个待合并新簇
  * 搜索合适的邻居簇
  * 合并进邻居簇（形成“新簇”）
* 对每个新簇
  * 拓展该簇



# 分步流程
假设我有数据结构hashmap, hashset

维护hashmap：粒子->所属簇的列表（不使用不定长列表，而是使用一个有限数组，它只存当前最小的那几个簇）

## 从activeParticles中移除被切割粒子
* 构造被切割粒子的hashset
* 对activeParticles中的每个粒子（并行）
  * 检查该粒子是否在被切割粒子的hashset中
  * 如果不在的话，就什么也不做
  * 否则将该位置设为非法值
* 流压缩activeParticles（并行）

## 从粒子->所属簇列表的hashmap中移除被切割粒子
* 对每个被切割粒子（并行）
  * 从粒子->所属簇列表的hashmap中移除该粒子（不一定非得要真移除掉）

## 由被切割粒子确定被切割簇
* 使用之前构造好的被切割粒子的hashset
* 对每个簇（并行）
  * 检查其每个粒子
    * 若该粒子属于被切割粒子的hashset的话
      * 原子操作，将该簇加入被切割簇列表的插入索引
      * 并结束循环
    * 否则继续检查下一粒子

## 对每个被切割簇搜索极大连通子图
* 参考2018 A High-Performance Connected Components Implementation for GPUs
* 构造长度为所有被切割簇粒子数量总和的两个数组：
  * 一个是粒子id数组ids
  * 一个是偏移量数组offsets
  * 第i个待合并新簇的id范围是`[ids[offsets[i-1]], ids[offsets[i]])`
* 遍历每个被切割簇
  * 构造hashmap：该簇中所有的粒子id -> 在列表里的index
  * 构造长度为簇中粒子数量的定长数组parent: parent\[i\]为index为i的粒子在并查集中的父节点的index。
  * 对簇中的每个粒子（并行）
    * 计算其邻居的index，存储在大数组neighbors中（使用粒子id的hashmap）
  * 将粒子看作顶点，相邻粒子间看作有边，进行极大连通子图搜索：
    * 对每个顶点（并行）
      * 初始化parent：比自己index小的任意一个邻居的index，如果不存在，就用自己的index
    * 对每个顶点（并行）
      * 检索其邻居（neighbors）
      * 若邻居index比自己的大，什么也不做。
      * 若邻居index比自己的小，
        * 比较自己所属集合的根节点和邻居的根节点，将较大index的合并进较小index的
    * 对每个顶点（并行）
      * 搜索所属集合的根节点，将其设为自己的父节点：`parent[i] = find_root(i)`
    * 构造辅助数组：索引数组indices
      * 长度等于顶点数
      * 生成0,1,2,...,n-1的序列（thrust::sequence）
    * 以parent为key对indices排序（可以直接使用thrust::sort_by_key来并行执行）
    * 构造辅助数组：偏移量子数组subOffsets
      * 构造和粒子id列表等长的数组
      * 对parent中的每个元素i（并行）
        * 若左边不存在元素、或和左边的元素相等，则设`subOffsets[i]=0`
        * 否则若与左边元素不等，则设`subOffsets[i]=i`
      * 对subOffsets进行流压缩（并行）
    * 返回indices和subOffsets，结束极大连通子图搜索
  * 根据indices和subOffset更新ids和offsets
  * 从簇列表中删除该被切割簇（并更新粒子id->所属簇的hashmap）

## 将每个待合并新簇合并至邻居簇
* 对每个待合并新簇（并行）
  * 构造包含该簇中所有粒子id的hashset
  * 对每个该簇中的粒子
    * 搜索其不在该簇中的邻居，对其邻居进行：
      * 检索其所属簇列表中的每一项，如果簇大小+该待合并新簇大小<=最大簇大小的话，就使用CAS尝试替换簇大小列表里该簇的大小（见下面的CAS测试替换大小）
        * 如果替换成功，就记录下来插入簇的ID和插入的起始索引
        * 否则再次尝试当前项
      * 如果>=最大簇大小，就检查下一项
* 对每个待合并新簇（并行）
  * 若在上一步中替换成功，则将新簇合并进去，并将被合并修改的簇的ID记录进已修改簇列表中（TODO：会有重复项，考虑使用一个hashset去重）
  * 若在上一步中替换失败，则该新簇独立成簇。建立新簇，并将新簇的ID记录进已修改簇列表中（不可能重复，不用去重）
* 对每个已修改簇
  * 更新其粒子的所属簇列表（并行）

CAS测试替换大小：
``` c++
newSize = nowSize + delta
if CAS(clusterSizes+now, nowSize, newSize) == nowSize:
  succeed
else
  fail
```

## 小簇拓展
* 检查每个已修改簇（并行）
  * 构造包含该簇中所有粒子id的hashset
  * 当该簇大小小于设定的阈值时
    * 随机选择该簇中的某个粒子，搜索其不在该簇中的邻居粒子（使用粒子id的hashset）
    * 若不存在这样的粒子，则更换随机选择，直到所有粒子都被试过，此时终止循环
      * 这一步可以考虑设置随机尝试次数的阈值
    * 若存在这样的粒子，则将其加入当前簇中，并更新hashset和hashmap，继续循环

## 重新计算rigidLocalPos
* 对每个簇（并行） // TODO: 以后再改成需要的时候再更新
  * 计算rigidLocalPos






